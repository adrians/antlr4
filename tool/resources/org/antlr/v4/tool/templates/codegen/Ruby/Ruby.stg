/*
 * [The "BSD license"]
 *  Copyright (c) 2012-2019 Num Technologies Ltd, UK.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

rubyTypeInitMap ::= [
	"bool":"false",
	"int":"0",
	"float":"0.0",
	"str":"",
	default:"{}" // anything other than a primitive type is an object
]

// args must be <object-model-object>, <fields-resulting-in-STs>

ParserFile(file, parser, namedActions, contextSuperClass) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>

require '../../antlr4/runtime/Ruby/antlr4/PredictionContextCache'
require '../../antlr4/runtime/Ruby/antlr4/Parser'
require '../../antlr4/runtime/Ruby/antlr4/ParserATNSimulator'
require '../../antlr4/runtime/Ruby/antlr4/ParserRuleContext'
require "./<file.grammarName>Listener"
require "./<file.grammarName>Visitor"

<if(file.genPackage)>
module <file.genPackage>
<endif>

<if(file.genListener)>
the<file.grammarName>Listener = <file.grammarName>Listener.new
<endif>
<if(file.genVisitor)>
the<file.grammarName>Visitor = <file.grammarName>Visitor.new
<endif>

<namedActions.header>

<parser>

<if(file.genPackage)>
end
<endif>
>>

ListenerFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
module <file.genPackage>
<endif>
<header>
require '../../antlr4/runtime/Ruby/antlr4/ParseTreeListener'

class <file.grammarName>Listener \< ParseTreeListener
	<file.listenerNames:{lname |

def enter<lname; format="cap">(ctx)
end

def exit<lname; format="cap">(ctx)
end
}; separator="\n">
end
<if(file.genPackage)>
end
<endif>
>>

BaseListenerFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<header>
require '../../antlr4/runtime/Ruby/antlr4/ParserRuleContext'
require '../../antlr4/runtime/Ruby/antlr4/ErrorNode'
require '../../antlr4/runtime/Ruby/antlr4/TerminalNode'
require './<file.grammarName>Listener'

<if(file.genPackage)>
module <file.genPackage>
<endif>

class <file.grammarName>BaseListener \< <file.grammarName>Listener
	<file.listenerNames:{lname |

 def enter<lname; format="cap">(ctx)
 end

 def exit<lname; format="cap">(ctx)
 end}; separator="\n">

 def enterEveryRule(ctx)
 end

 def exitEveryRule(ctx)
 end

 def visitTerminal(node)
 end

 def visitErrorNode(node)
 end

end
<if(file.genPackage)>
end
<endif>

>>

VisitorFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
require '../../antlr4/runtime/Ruby/antlr4/ParseTreeVisitor'

<if(file.genPackage)>
module <file.genPackage>
<endif>
<header>

class <file.grammarName>Visitor \< ParseTreeVisitor
	<file.visitorNames:{lname |
def visit<lname; format="cap">(ctx)
end}; separator="\n">
end
<if(file.genPackage)>
end
<endif>

>>

BaseVisitorFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>

require '../../antlr4/runtime/Ruby/antlr4/AbstractParseTreeVisitor'


<if(file.genPackage)>
module <file.genPackage>
<endif>
<header>

 class <file.grammarName>BaseVisitor \< AbstractParseTreeVisitor
	<file.visitorNames:{lname |
def visit<lname; format="cap">( ctx)
 return visitChildren(ctx)
 end
 }; separator="\n">

end
<if(file.genPackage)>
end
<endif>

>>

fileHeader(grammarFileName, ANTLRVersion) ::= <<
# Generated from <grammarFileName; format="java-escape"> by ANTLR <ANTLRVersion>
>>

Parser(parser, funcs, atn, sempredFuncs, superClass) ::= <<
<Parser_(ctor="parser_ctor", ...)>
>>

Parser_(parser, funcs, atn, sempredFuncs, ctor, superClass) ::= <<

class <parser.name> \< <superClass; null="Parser">

	@@_decisionToDFA = nil
	@@_sharedContextCache = PredictionContextCache.new()
	<if(parser.tokens)>
		<parser.tokens:{k | <k>=<parser.tokens.(k)>}; separator="\n", wrap, anchor>
	<endif>
		<parser.rules:{r | RULE_<r.name> = <r.index>}; separator="\n", wrap, anchor>

	@@ruleNames = [
			<parser.ruleNames:{r | "<r>"}; separator=", ", wrap, anchor>
	]

	<vocabulary(parser.literalNames, parser.symbolicNames)>

	def getGrammarFileName()
	 return "<parser.grammarFileName; format="java-escape">"
	end

	def getRuleNames()
	 return @@ruleNames
	end

	def getSerializedATN()
	 return @@_serializedATN
	end

	def getATN()
	 return @@_ATN
	end

	<namedActions.members>
	<parser:(ctor)()>
	<funcs; separator="\n">

<if(sempredFuncs)>
	def sempred( _localctx,  ruleIndex,  predIndex)
		case (ruleIndex)
		<parser.sempredFuncs.values:{f|
when <f.ruleIndex>
	return <f.name>_sempred(_localctx, predIndex)}; separator="\n">
		end
		return true
	end
	<sempredFuncs.values; separator="\n">
<endif>

	<atn>
end
>>

vocabulary(literalNames, symbolicNames) ::= <<
@@_LITERAL_NAMES = [
		<literalNames:{t | <t>}; null="nil", separator=", ", wrap, anchor>
]

@@_SYMBOLIC_NAMES = [
		<symbolicNames:{t | <t>}; null="nil", separator=", ", wrap, anchor>
]

@@VOCABULARY =  VocabularyImpl.new(@@_LITERAL_NAMES, @@_SYMBOLIC_NAMES)

>>

dumpActions(recog, argFuncs, actionFuncs, sempredFuncs) ::= <<
<if(actionFuncs)>

def action( _localctx,  ruleIndex,  actionIndex)
	case (ruleIndex)
	<recog.actionFuncs.values:{f|
when <f.ruleIndex>
	<f.name>_action(_localctx, actionIndex);
	}; separator="\n">
	end
end
<actionFuncs.values; separator="\n">
<endif>
<if(sempredFuncs)>

def sempred( _localctx,  ruleIndex,  predIndex)
	case (ruleIndex)
	<recog.sempredFuncs.values:{f|
when <f.ruleIndex>
	return <f.name>_sempred(_localctx, predIndex)}; separator="\n">
	end
	return true
end
<sempredFuncs.values; separator="\n">
<endif>
>>

parser_ctor(p) ::= <<
def initialize( input)
	super(input)
	@_interp =  ParserATNSimulator.new(self,@@_ATN,@@_decisionToDFA,@@_sharedContextCache)
end
>>

/* This generates a private method since the actionIndex is generated, making an
 * overriding implementation impossible to maintain.
 */
RuleActionFunction(r, actions) ::= <<
def <r.name>_action( _localctx,  actionIndex)
	case (actionIndex)
	<actions:{index|
when <index>
	<actions.(index)>
	}; separator="\n">
	end
end
>>

/* This generates a private method since the predIndex is generated, making an
 * overriding implementation impossible to maintain.
 */
RuleSempredFunction(r, actions) ::= <<
def <r.name>_sempred( _localctx,  predIndex)
	case (predIndex)
	<actions:{index|
when <index>
	return <actions.(index)>}; separator="\n">
	end
	return true
end
>>

RuleFunction(currentRule,args,code,locals,ruleCtx,altLabelCtxs,namedActions,finallyAction,postamble,exceptions) ::= <<

<ruleCtx>
<altLabelCtxs:{l | <altLabelCtxs.(l)>}; separator="\n">

def <currentRule.name>(<args; separator=",">)
	@_localctx =  <currentRule.ctxType>.new(@_ctx, getState()<currentRule.args:{a | , <a.name>}>)
	enterRule(@_localctx, <currentRule.startState>, RULE_<currentRule.name>)
	<namedActions.init>
	<locals; separator="\n">
	begin
<if(currentRule.hasLookaheadBlock)>
		_alt = 0
<endif>
		<code>
		<postamble; separator="\n">
		<namedActions.after>
	<if(exceptions)>
	<exceptions; separator="\n">
	<else>
	rescue RecognitionException => re
		@_localctx.exception = re
		@_errHandler.reportError(self, re)
		@_errHandler.recover(this, re)
	<endif>
	ensure
		<finallyAction>
		exitRule()
	end
	return _localctx
end
>>

LeftRecursiveRuleFunction(currentRule,args,code,locals,ruleCtx,altLabelCtxs,
	namedActions,finallyAction,postamble) ::=
<<

<ruleCtx>
<altLabelCtxs:{l | <altLabelCtxs.(l)>}; separator="\n">

def<currentRule.name>(<args; separator=", ">)
	return <currentRule.name>(0<currentRule.args:{a | , <a.name>}>)
end

def <currentRule.name>( _p<args:{a | , <a>}>)
	 @_parentctx = _ctx
	 @_parentState = getState()
	@_localctx =  <currentRule.ctxType>.new(_ctx, _parentState<currentRule.args:{a | , <a.name>}>)
	 @_prevctx = @_localctx
	 _startState = <currentRule.startState>
	enterRecursionRule(@_localctx, <currentRule.startState>, RULE_<currentRule.name>, _p)
	<namedActions.init>
	<locals; separator="\n">
	begin
<if(currentRule.hasLookaheadBlock)>
		 _alt
<endif>
		<code>
		<postamble; separator="\n">
		<namedActions.after>

	rescue RecognitionException => re
		@_localctx.exception = re
		@_errHandler.reportError(this, re)
		@_errHandler.recover(this, re)

	ensure
		<finallyAction>
		unrollRecursionContexts(_parentctx)
	end
	return _localctx
end
>>

CodeBlockForOuterMostAlt(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= <<
<if(currentOuterMostAltCodeBlock.altLabel)>@_localctx =  <currentOuterMostAltCodeBlock.altLabel; format="cap">Context.new(_localctx)<endif>
enterOuterAlt(_localctx, <currentOuterMostAltCodeBlock.alt.altNum>)
<CodeBlockForAlt(currentAltCodeBlock=currentOuterMostAltCodeBlock, ...)>
>>

CodeBlockForAlt(currentAltCodeBlock, locals, preamble, ops) ::= <<

<locals; separator="\n">
<preamble; separator="\n">
<ops; separator="\n">
>>

LL1AltBlock(choice, preamble, alts, error) ::= <<
setState(<choice.stateNumber>)
@_errHandler.sync(self)
<if(choice.label)><labelref(choice.label)> = _input.LT(1)<endif>
<preamble; separator="\n">
case (_input.LA(1))
<if(choice.altLook && alts)>
<choice.altLook, alts:{look, alt | when <look:{l | <parser.name><l>}; separator=", ">
	<alt>}; separator="\n\n">
<endif>
else
	<error>
end
>>

LL1OptionalBlock(choice, alts, error) ::= <<
setState(<choice.stateNumber>)
@_errHandler.sync(self)
case (_input.LA(1))
<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	}; separator="\n">
else
end
>>

LL1OptionalBlockSingleAlt(choice, expr, alts, preamble, error, followExpr) ::= <<
setState(<choice.stateNumber>)
@_errHandler.sync(self)
<preamble; separator="\n">
if (<expr>)
	<alts; separator="\n">
end
<!else if ( !(<followExpr>) ) <error>!>
>>

LL1StarBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
setState(<choice.stateNumber>)
@_errHandler.sync(self)
<preamble; separator="\n">
while (<loopExpr>)
	<alts; separator="\n">
	setState(<choice.loopBackStateNumber>)
	@_errHandler.sync(self)
	<iteration>
end
>>

LL1PlusBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
setState(<choice.blockStartStateNumber>) <! alt block decision !>
@_errHandler.sync(self)
<preamble; separator="\n">
loop do
	<alts; separator="\n">
	setState(<choice.stateNumber>) <! loopback/exit decision !>
	@_errHandler.sync(self)
	<iteration>
 break if (! <loopExpr> )
end
>>

// LL(*) stuff

AltBlock(choice, preamble, alts, error) ::= <<
setState(<choice.stateNumber>)
@_errHandler.sync(self)
<if(choice.label)><labelref(choice.label)> = _input.LT(1)<endif>
<preamble; separator="\n">
case ( getInterpreter().adaptivePredict(_input,<choice.decision>,_ctx) )
<alts:{alt |
when <i>
	<alt>
	}; separator="\n">
end
>>

OptionalBlock(choice, alts, error) ::= <<
setState(<choice.stateNumber>)
@_errHandler.sync(self)
case ( getInterpreter().adaptivePredict(_input,<choice.decision>,_ctx) )
<alts:{alt |
when <i><if(!choice.ast.greedy)>+1<endif>
	<alt>
	}; separator="\n">
end
>>

StarBlock(choice, alts, sync, iteration) ::= <<
setState(<choice.stateNumber>)
@_errHandler.sync(self);
@_alt = getInterpreter().adaptivePredict(_input,<choice.decision>,_ctx)
while ( _alt!=<choice.exitAlt> && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER )
	if ( _alt==1<if(!choice.ast.greedy)>+1<endif> )
		<iteration>
		<alts> <! should only be one !>
	end
	setState(<choice.loopBackStateNumber>)
	@_errHandler.sync(self)
	@_alt = getInterpreter().adaptivePredict(_input,<choice.decision>,_ctx)
end
>>

PlusBlock(choice, alts, error) ::= <<
setState(<choice.blockStartStateNumber>) <! alt block decision !>
@_errHandler.sync(self)
@_alt = 1<if(!choice.ast.greedy)>+1<endif>
loop do
	case (@_alt)
	<alts:{alt|
when <i><if(!choice.ast.greedy)>+1<endif>
	<alt>
	}; separator="\n">
	else
		<error>
	end
	setState(<choice.loopBackStateNumber>) <! loopback/exit decision !>
	@_errHandler.sync(self)
	@_alt = getInterpreter().adaptivePredict(_input,<choice.decision>,_ctx)
    break if !( _alt!=<choice.exitAlt> && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER )
end
>>

Sync(s) ::= "sync(<s.expecting.name>);"

ThrowNoViableAlt(t) ::= "raise NoViableAltException self"

TestSetInline(s) ::= <<
<s.bitsets:{bits | <if(rest(rest(bits.ttypes)))><bitsetBitfieldComparison(s, bits)><else><bitsetInlineComparison(s, bits)><endif>}; separator=" || ">
>>

// Ruby language spec 15.19 - shift operators mask operands rather than overflow to 0... need range test
testShiftInRange(shiftAmount) ::= <<
((<shiftAmount>) & ~0x3f) == 0
>>

// produces smaller bytecode only when bits.ttypes contains more than two items
bitsetBitfieldComparison(s, bits) ::= <%
(<testShiftInRange({<offsetShift(s.varName, bits.shift)>})> && ((1 \<\< <offsetShift(s.varName, bits.shift)>) & (<bits.ttypes:{ttype | (1 \<\< <offsetShift(ttype, bits.shift)>)}; separator=" | ">)) != 0)
%>

isZero ::= [
"0":true,
default:false
]

offsetShift(shiftAmount, offset) ::= <%
<if(!isZero.(offset))>(<shiftAmount> - <offset>)<else><shiftAmount><endif>
%>

// produces more efficient bytecode when bits.ttypes contains at most two items
bitsetInlineComparison(s, bits) ::= <%
<bits.ttypes:{ttype | <s.varName>==<ttype>}; separator=" || ">
%>

cases(ttypes) ::= <<
<ttypes:{t | when <t>}; separator="\n">
>>

InvokeRule(r, argExprsChunks) ::= <<
setState(<r.stateNumber>)
<if(r.labels)><r.labels:{l | <labelref(l)> = }><endif><r.name>(<if(r.ast.options.p)><r.ast.options.p><if(argExprsChunks)>,<endif><endif><argExprsChunks>)
>>

MatchToken(m) ::= <<
setState(<m.stateNumber>)
<if(m.labels)><m.labels:{l | <labelref(l)> = }><endif>match(<m.name>)
>>

MatchSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, false)>"

MatchNotSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, true)>"

CommonSetStuff(m, expr, capture, invert) ::= <<
setState(<m.stateNumber>)
<if(m.labels)><m.labels:{l | <labelref(l)> = }>_input.LT(1)<endif>
<capture>
if ( <if(invert)><m.varName> \<= 0 || <else>!<endif>(<expr>) )
	<if(m.labels)><m.labels:{l | <labelref(l)> = (Token)}><endif>_errHandler.recoverInline(this)

else
	if ( _input.LA(1)==Token.EOF )
	  @matchedEOF = true
	end
	@_errHandler.reportMatch(self)
	consume()
end
>>

Wildcard(w) ::= <<
setState(<w.stateNumber>)
<if(w.labels)><w.labels:{l | <labelref(l)> = }><endif>matchWildcard()
>>

// ACTION STUFF

Action(a, foo, chunks) ::= "<chunks>"

ArgAction(a, chunks) ::= "<chunks>"

SemPred(p, chunks, failChunks) ::= <<
setState(<p.stateNumber>)
if (!(<chunks>))
  raise FailedPredicateException, self, <p.predicate><if(failChunks)>, <failChunks><elseif(p.msg)>, <p.msg><endif>)
end
>>

ExceptionClause(e, catchArg, catchAction) ::= <<
rescue <catchArg>
	<catchAction>
end
>>

// lexer actions are not associated with model objects

LexerSkipCommand()  ::= "skip()"
LexerMoreCommand()  ::= "more()"
LexerPopModeCommand() ::= "popMode()"

LexerTypeCommand(arg, grammar)      ::= "@_type = <arg>"
LexerChannelCommand(arg, grammar)   ::= "@_channel = <arg>"
LexerModeCommand(arg, grammar)      ::= "@_mode = <arg>"
LexerPushModeCommand(arg, grammar)  ::= "pushMode(<arg>)"

ActionText(t) ::= "<t.text>"
ActionTemplate(t) ::= "<t.st>"
ArgRef(a) ::= "_localctx.<a.name>"
LocalRef(a) ::= "_localctx.<a.name>"
RetValueRef(a) ::= "_localctx.<a.name>"
QRetValueRef(a) ::= "<ctx(a)>.<a.dict>.<a.name>"
/** How to translate $tokenLabel */
TokenRef(t) ::= "<ctx(t)>.<t.name>"
LabelRef(t) ::= "<ctx(t)>.<t.name>"
ListLabelRef(t) ::= "<ctx(t)>.<ListLabelName(t.name)>"
SetAttr(s,rhsChunks) ::= "<ctx(s)>.<s.name> = <rhsChunks>;"

TokenLabelType() ::= "<file.TokenLabelType; null={Token}>"
InputSymbolType() ::= "<file.InputSymbolType; null={Token}>"

TokenPropertyRef_text(t) ::= "(<ctx(t)>.<t.label>!=nil?<ctx(t)>.<t.label>.getText():nil)"
TokenPropertyRef_type(t) ::= "(<ctx(t)>.<t.label>!=nil?<ctx(t)>.<t.label>.getType():0)"
TokenPropertyRef_line(t) ::= "(<ctx(t)>.<t.label>!=nil?<ctx(t)>.<t.label>.getLine():0)"
TokenPropertyRef_pos(t) ::= "(<ctx(t)>.<t.label>!=nil?<ctx(t)>.<t.label>.getCharPositionInLine():0)"
TokenPropertyRef_channel(t) ::= "(<ctx(t)>.<t.label>!=nil?<ctx(t)>.<t.label>.getChannel():0)"
TokenPropertyRef_index(t) ::= "(<ctx(t)>.<t.label>!=nil?<ctx(t)>.<t.label>.getTokenIndex():0)"
TokenPropertyRef_int(t) ::= "(<ctx(t)>.<t.label>!=nil?Integer.valueOf(<ctx(t)>.<t.label>.getText()):0)"

RulePropertyRef_start(r) ::= "(<ctx(r)>.<r.label>!=nil?(<ctx(r)>.<r.label>.start):nil)"
RulePropertyRef_stop(r)	 ::= "(<ctx(r)>.<r.label>!=nil?(<ctx(r)>.<r.label>.stop):nil)"
RulePropertyRef_text(r)	 ::= "(<ctx(r)>.<r.label>!=nil?_input.getText(<ctx(r)>.<r.label>.start,<ctx(r)>.<r.label>.stop):nil)"
RulePropertyRef_ctx(r)	 ::= "<ctx(r)>.<r.label>"
RulePropertyRef_parser(r)	 ::= "self"

ThisRulePropertyRef_start(r) ::= "@_localctx.start"
ThisRulePropertyRef_stop(r)	 ::= "@_localctx.stop"
ThisRulePropertyRef_text(r)	 ::= "@_input.getText(_localctx.start, _input.LT(-1))"
ThisRulePropertyRef_ctx(r)	 ::= "@_localctx"
ThisRulePropertyRef_parser(r)	 ::= "self"

NonLocalAttrRef(s)		 ::= "((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>)).<s.name>"
SetNonLocalAttr(s, rhsChunks)	  ::=
	"((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>)).<s.name> = <rhsChunks>;"

AddToLabelList(a) ::= "<ctx(a.label)>.<a.listName>.push(<labelref(a.label)>);"

TokenDecl(t) ::= "<TokenLabelType()> <t.name>"
TokenTypeDecl(t) ::= "<t.name> = 0"
TokenListDecl(t) ::= "<t.name> = []"
RuleContextDecl(r) ::= "<r.name> = nil"
RuleContextListDecl(rdecl) ::= "<rdecl.name> = []"

ContextTokenGetterDecl(t)      ::= <<
def <t.name>()
  return getToken(<parser.name>.<t.name>, 0)
end
>>
ContextTokenListGetterDecl(t)  ::= <<
def <t.name>()
 return getTokens(<parser.name>.<t.name>)
end
>>
ContextTokenListIndexedGetterDecl(t)  ::= <<
def <t.name>_i( i)
	return getToken(<parser.name>.<t.name>, i)
end
>>
ContextRuleGetterDecl(r)       ::= <<
def <r.name>()
	return getRuleContext("<r.ctxName>",0)
end
>>
ContextRuleListGetterDecl(r)   ::= <<
def <r.name>()
	return getRuleContexts("<r.ctxName>")
end
>>
ContextRuleListIndexedGetterDecl(r)   ::= <<
def <r.name>_i( i)
	return getRuleContext("<r.ctxName>",i)
end
>>

LexerRuleContext() ::= "RuleContext"

/** The rule context name is the rule followed by a suffix; e.g.,
 *	r becomes rContext.
 */
RuleContextNameSuffix() ::= "Context"

ImplicitTokenLabel(tokenName) ::= "<tokenName>"
ImplicitRuleLabel(ruleName)	  ::= "<ruleName>"
ImplicitSetLabel(id)		  ::= "_tset<id>"
ListLabelName(label)		  ::= "<label>"

CaptureNextToken(d) ::= "<d.varName> = _input.LT(1)"
CaptureNextTokenType(d) ::= "<d.varName> = _input.LA(1)"

StructDecl(struct,ctorAttrs,attrs,getters,dispatchMethods,interfaces,extensionMembers)
	::= <<
 class <struct.name> \< <if(contextSuperClass)><contextSuperClass><else>ParserRuleContext<endif><if(interfaces)> <endif>
	<attrs:{a | attr_accessor :<a>}; separator="\n">
	<getters:{g | <g>}; separator="\n">
	<if(ctorAttrs)>def initialize( parent,  invokingState) \n super(parent, invokingState)\nend<endif>
	def initialize( parent,  invokingState<ctorAttrs:{a | , <a>}>)
		super(parent, invokingState)
		<struct.ctorAttrs:{a | @<a.name> = <a.name>}; separator="\n">
	end
	def getRuleIndex()
	 return RULE_<struct.derivedFromName>
	end
<if(struct.provideCopyFrom)> <! don't need copy unless we have subclasses !>
	def initialize()
	end
	def copyFrom( ctx)
		super.copyFrom(ctx)
		<struct.attrs:{a | @<a.name> = ctx.<a.name>}; separator="\n">
	end
<endif>
	<dispatchMethods; separator="\n">
	<extensionMembers; separator="\n">
end
>>

AltLabelStructDecl(struct,attrs,getters,dispatchMethods) ::= <<
 class <struct.name> \< <currentRule.name; format="cap">Context
	<attrs:{a | attr_accessor :<a>}; separator="\n">
	<getters:{g | <g>}; separator="\n">
	def initialize(<currentRule.name; format="cap">Context ctx)
	 copyFrom(ctx)
	end
	<dispatchMethods; separator="\n">
end
>>

ListenerDispatchMethod(method) ::= <<
def <if(method.isEnter)>enter<else>exit<endif>Rule( listener)
	if ( listener.is_a? <parser.grammarName>Listener )
	  listener.<if(method.isEnter)>enter<else>exit<endif><struct.derivedFromName; format="cap">(self)
	end
end
>>

VisitorDispatchMethod(method) ::= <<

def accept(visitor)
	if ( visitor.is_a? <parser.grammarName>Visitor )
	  return visitor.visit<struct.derivedFromName; format="cap">(self)
	else
	 return visitor.visitChildren(self)
	end
end
>>

AttributeDecl(d) ::= "<d.type> <d.name><if(d.initValue)> = <d.initValue><endif>"

/** If we don't know location of label def x, use this template */
labelref(x) ::= "<if(!x.isLocal)>((<x.ctx.name>)_localctx).<endif><x.name>"

/** For any action chunk, what is correctly-typed context struct ptr? */
ctx(actionChunk) ::= "((<actionChunk.ctx.name>)_localctx)"

// used for left-recursive rules
recRuleAltPredicate(ruleName,opPrec)  ::= "precpred(_ctx, <opPrec>)"
recRuleSetReturnAction(src,name)	  ::= "$<name>=$<src>.<name>"
recRuleSetStopToken()                 ::= "@_ctx.stop = _input.LT(-1)"

recRuleAltStartAction(ruleName, ctxName, label, isListLabel) ::= <<
@_localctx =  <ctxName>Context.new(@_parentctx, @_parentState)
<if(label)>
<if(isListLabel)>
@_localctx.<label>.push(@_prevctx)
<else>
@_localctx.<label> = @_prevctx
<endif>
<endif>
<if(label)>@_localctx.<label> = @_prevctx<endif>
pushNewRecursionContext(@_localctx,@ _startState, RULE_<ruleName>)
>>

recRuleLabeledAltStartAction(ruleName, currentAltLabel, label, isListLabel) ::= <<
@_localctx =  <currentAltLabel; format="cap">Context.new( <ruleName; format="cap">Context.new(@_parentctx, @_parentState))
<if(label)>
<if(isListLabel)>
@_localctx.<label>.push(@_prevctx)
<else>
@_localctx.<label> = @_prevctx
<endif>
<endif>
pushNewRecursionContext(@_localctx, @_startState, RULE_<ruleName>)
>>

recRuleReplaceContext(ctxName) ::= <<
@_localctx = <ctxName>Context.new(@_localctx)
@_ctx = @_localctx
@_prevctx = @_localctx
>>

recRuleSetPrevCtx() ::= <<
if ( @_parseListeners!=nil )
 triggerExitRuleEvent()
end
@_prevctx = @_localctx
>>


LexerFile(lexerFile, lexer, namedActions) ::= <<
<fileHeader(lexerFile.grammarFileName, lexerFile.ANTLRVersion)>
<namedActions.header>
require '../../antlr4/runtime/Ruby/antlr4/ATNDeserializer'
require '../../antlr4/runtime/Ruby/antlr4/LexerATNSimulator'
require '../../antlr4/runtime/Ruby/antlr4/DFA'
require '../../antlr4/runtime/Ruby/antlr4/Token'
require '../../antlr4/runtime/Ruby/antlr4/PredictionContextCache'
require '../../antlr4/runtime/Ruby/antlr4/VocabularyImpl'
require '../../antlr4/runtime/Ruby/antlr4/Lexer'

<if(lexerFile.genPackage)>
module <lexerFile.genPackage>
<endif>

<lexer>

<if(lexerFile.genPackage)>
end
<endif>
>>

Lexer(lexer, atn, actionFuncs, sempredFuncs, superClass) ::= <<

class <lexer.name> <"\<"> <superClass; null="Lexer">

	@_decisionToDFA
	@_sharedContextCache = PredictionContextCache.new
	<if(lexer.tokens)>
		<lexer.tokens:{k | <k>=<lexer.tokens.(k)>}; separator="\n", wrap, anchor>
	<endif>
	<if(lexer.channels)>
		<lexer.channels:{c | <c>=<lexer.channels.(c)>}; separator="\n", wrap, anchor>
	<endif>
	<if(rest(lexer.modes))>
		<rest(lexer.modes):{m | <m>=<i>}; separator="\n", wrap, anchor>
	<endif>
	@@channelNames = [
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"<if (lexer.channels)>, <lexer.channels:{c| "<c>"}; separator=", ", wrap, anchor><endif>
	]

	@@modeNames = [
		<lexer.modes:{m| "<m>"}; separator=", ", wrap, anchor>
	]

	@@ruleNames  = [
			<lexer.ruleNames:{r | "<r>"}; separator=", ", wrap, anchor>
	]

	<vocabulary(lexer.literalNames, lexer.symbolicNames)>

	<namedActions.members>

	<atn>

	@@_decisionToDFA = []

	def initialize(input)
		super(input)

		i = 0
		while i \< @@_ATN.getNumberOfDecisions()
			@@_decisionToDFA[i] = DFA.new(@@_ATN.getDecisionState(i), i)
			i+=1
		end

		@_interp = LexerATNSimulator.new(self,@@_ATN,@@_decisionToDFA,@_sharedContextCache)
	end

	def getGrammarFileName()
	 return "<lexer.grammarFileName>"
	end

	def getRuleNames()
	 return @@ruleNames
	end

	def getSerializedATN()
	  return @@_serializedATN
	end

	def getChannelNames()
	  return @@channelNames
	end

	def getModeNames()
	  return @@modeNames
	end

	def getATN()
	 return @@_ATN
	end

	<dumpActions(lexer, "", actionFuncs, sempredFuncs)>
end
>>

SerializedATN(model) ::= <<
<if(rest(model.segments))>
@@_serializedATNSegments = <length(model.segments)>
<model.segments:{segment|@@_serializedATNSegment<i0> =
	"<segment; wrap={"+<\n><\t>"}>"}; separator="\n">
@@_serializedATN = Utils.join([<model.segments:{segment | _serializedATNSegment<i0>}; separator=",\n">],"")
<else>
@@_serializedATN = ["<model.serialized; wrap={",<\n>    "}>"].join("")
<endif>

@@_ATN = ATNDeserializer.new().deserialize(@@_serializedATN)

>>

/** Using a type to init value map, try to init a type; if not in table
 *	must be an object, default value is "nil".
 */
initValue(typeName) ::= <<
<rubyTypeInitMap.(typeName)>
>>

codeFileExtension() ::= ".rb"
